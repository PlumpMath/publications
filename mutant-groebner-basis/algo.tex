Let $F = \{\sys \} \subset \FX$, and $\mathcal{I}=\ideal{\sys}$ be the ideal generated by $F$.
Recall that any element $f \in \mathcal{I}$ can be written as
$$f=\sum_{i=0}^{m-1}h_i \cdot f_i, \mbox{ with } h_i \in  \FX.$$
Note that this representation is usually not unique. Following the terminology of \cite{mxl}, we call the {\it level} of the representation $\sum_{f_i \in F}h_i \cdot f_i$ of $f$ the maximum degree of $\{h_i \cdot f_i \mid f_i \in F\}$. We call the {\it level} of $f$ the minimal level of all its representations. We can then define the concept of a {\it mutant}~\cite{mxl,mxl2,mxl3}.
\begin{definition}
Given a set of generators $F$ of an ideal $\mathcal{I}$, a polynomial $f \in \mathcal{I}$ is a  {\rm mutant} if its total degree is strictly less than its level.       
\end{definition}
A mutant corresponds to a ``low-degree" relation occurring during XL or more generally during any Gr\"obner basis computation. 
It follows from the discussion in Section~\ref{sec:gb} that, in the language of commutative algebra, 
a mutant occurs when an S-polynomial has a lower-degree leading monomial after reduction by $F$ and if this new leading monomial was not in the set $\LM{F}$ before reduction.

The concept of mutant has recently motivated the proposal of a family XL-style algorithms~\cite{mxl,mxl2,mxl3,mxl4}. We discuss below the most prominent, namely the MXL$_3$ algorithm.

\subsection{MXL$_3$ Algorithm} \label{sec:mxl3}
The MXL family of algorithms improves the XL algorithm using the mutant concept. In particular, the MXL$_3$ (Algorithmm~\ref{alg:mutantxl3}) differs from XL in the following respects:
\begin{enumerate}
 \item Instead of ``blindly'' increasing the degree in each iteration of the algorithm, the MXL algorithms treat mutants at the lowest possible degree, (cf.\ line \ref{mxl3:mutants_found} in Algorithm~\ref{alg:mutantxl3}). This is the key contribution of the MXL algorithm \cite{mxl}.
 \item Instead of considering all elements $F_{=d}$ of the current degree $d$, MXL$_3$ only considers a subset of elements per iteration. It incrementally adds more elements of the current degree, if the elements of the previous iteration did not suffice to solve the system (cf.\ lines \ref{mxl3:partial_enlargement}-\ref{mxl3:partial_enlargement:end} in Algorithm~\ref{alg:mutantxl3}). This is called {\it partial enlargement} in \cite{mxl2,mxl3}. This is the key contribution of the MXL$_2$ algorithm \cite{mxl2}.
 \item XL terminates at the user-provided degree $D$, while MXL$_3$ does not require to fix the degree a priori. Instead, the algorithm will terminate once a Gr√∂bner basis was found using a new criterion (cf.\ line \ref{mxl3:terminate} in Algorithm~\ref{alg:mutantxl3}). This is the key contribution of the MXL$_3$ algorithm \cite{mxl3}.
\end{enumerate}
The pseudocode presented in Algorithm~\ref{alg:mutantxl3} is a slightly simplified variant of the MXL$_3$ algorithm; we use this presentation in Section~\ref{sec:relation} to compare it with the $F_4$ algorithm (Algorithm~\ref{alg:f4}).


\begin{algorithm}[ht]
\caption{MXL$_3$ (simplified)} 
\label{alg:mutantxl3}
\KwIn{$F$ -- a list of polynomials \sys $\in \FX$ spanning a zero-dimensional ideal.}
\KwResult{A Gr\"obner basis for $\ideal{\sys}$.}
\SetKw{KwAnd}{and}
\SetKw{KwOr}{or}
\Begin{
$D \longleftarrow \max\{\deg(f) \mid f \in F\}$\;
$d \longleftarrow \min\{\deg(f) \mid  f \in F\}$\;
$Mu \longleftarrow \varnothing$;
$newExtend \longleftarrow True$;
$x \longleftarrow x_0$;
$CL \longleftarrow d$\;
\While{True}{
  $\tilde{F}_{\leq d} \longleftarrow $ the row echelon form (or  matrix form) of $F_{\leq d}$\; 
  $Mu \longleftarrow Mu \cup \{f \in \tilde{F}_{\leq d} \mid \deg(f) < d\ \KwAnd\ \LM{f} \not\in \LM{F_{\leq d}}\}$\;  
  $F_{\leq d} \longleftarrow \tilde{F}_{\leq d}$\;
  \tcp{did we find mutants?}
  \eIf{$Mu \neq \varnothing$} {\nllabel{mxl3:mutants_found}
     $k \longleftarrow \min\{\deg(f) \mid  f \in Mu\}$\;
     $y \longleftarrow \max\{\LV{f}  \mid  f \in F_{\leq k+1}\}$\;\nllabel{mxl3:ychoice}
     $Mu_{=k}^+ \longleftarrow $ Multiply all elements of $Mu_{=k}$ by all variables $\leq y$\;
     $Mu \longleftarrow Mu \setminus Mu_{=k}$\;
     $F \longleftarrow F \cup Mu_{=k}^+$\;
     $d \longleftarrow k + 1$\;
  }{
  \tcp{does the basis contain all monomials of some degree $d_t$?}
  \If{$d < CL$ \KwAnd $M_{=d_t} \subseteq \LM{F}$ for some $1 \leq d_t \leq d$}{
    \tcp{We found a Gr\"obner basis}
    \Return{$F$}\; \nllabel{mxl3:terminate}
  }
  \tcp{did we do all enlargements at this degree already?}
  \eIf{$newExtend = True$}{
   $D \longleftarrow D + 1$\;
   $x \longleftarrow \min\{\LV{f} \mid f \in F_{=D-1}\}$\;
   $newExtend \longleftarrow False$\;
  }{
   \tcp{do partial enlargement and eliminate} 
   $x \longleftarrow \min\{\LV{f} \mid f \in F_{=D-1}\ \KwAnd\ \LV{f} > x\}$\; \nllabel{mxl3:partial_enlargement}
   $F^+ \longleftarrow $ Multiply all elements of $\LV{F,x}$ by all variables \sout{$\leq x$} without redundancies\;\nllabel{mxl3:incomplete}
   $F \longleftarrow F \cup F^+$\; \nllabel{mxl3:partial_enlargement:end}
   \If{$x= x_0$}{
    $newExtend \longleftarrow True$\;
    $CL \longleftarrow D$\;
   }
  }
  $d \longleftarrow D$\;
 }
}
}
\end{algorithm}
Our pseudocode has some minor differences with the pseudocode presented in \cite{mxl3}; we list these below:
\begin{description}
\item[Partial enlargement.] We disregard any partial enlargement strategy in the case when mutants were found. This matches the pseudocode in \cite{mxl3}. However, the actual implementation of MXL$_3$ does indeed use the partial enlargement when $Mu\neq \varnothing$ (i.e. mutants exist) \cite{mxl3-implementation}. We note that our pseudocode and that in \cite{mxl} are equivalent to MXL \cite{mxl} in this case. Since our work is mainly concerned with the concept of mutants, maintaining this simplification seems appropriate.

\item[Choice of $y$.] In line \ref{mxl3:ychoice} we set $y$ to  $\max\{\LV{f}  \mid  f \in F_{\leq k+1}\}$ instead of $\max\{\LV{f}  \mid  f \in Mu_{=k}\}$ since this allows reductions among all elements of degree $k+1$ instead of only those in $Mu_{=k+1}$. Restricting reduction to the elements of $Mu_{=k+1}$ could lead to incomplete reductions and thus results. The actual implementation of MXL$_3$ uses ``partial enlargement'' in this step and thus increases $y$ iteratively \cite{mxl3-implementation}.

\item[Incomplete reductions.] In line \ref{mxl3:incomplete} we removed the optimisation that only variables $\leq x$ are used for multiplication in the extension step. This optimisation can lead to an incorrect result as some reductions are never performed. As an example, consider $f = ab + 1$, $g = bc + a + b$ and $h = c$. The reduced Gr\"obner basis of the ideal $\ideal{f,g,h}$ over $\F_2[a,b,c]$ with respect to a degree lexicographical term ordering is $\{a + 1, b + 1, c\}$. However, the pseudocode of MXL$_3$ as described in \cite{mxl3} will not perform the necessary reductions. The leading variable of $h$ is $c$, thus $h \in \LV{F,c}$ and $h$ is never extended using any variable except $c$, since $a>c$ and $b>c$. 

Furthermore, the S-polynomial $S(f,g) = c\cdot f - a\cdot g = (abc + c) - (abc + ab + a) = ab + a + c$ is not constructed since $ag$ requires multiplication of $g$ in $\LV{F,b}$ by $a$ but $a>b$. Thus, on termination the output of MXL$_3$ is not a Gr\"obner basis. 

Our change matches Proposition 3 from \cite{mxl3}, which requires that for $H \longleftarrow \{t\cdot g \mid g \in G, t \textnormal{ a term and } \deg(t\cdot g) \leq D +1\}$ the reduced row echelon form of $H$ is $G$. However, this property is not enforced by MXL$_3$ as presented in pseudocode in \cite{mxl3}, since some $t \cdot g$ are prohibited from being constructed if $\deg(t) = 1$ and $t > \LV{g}$. We confirmed with the authors of \cite{mxl3} that their implementation catches up on those missing multiplications when $newExtend = True$ \cite{mxl3-implementation}.
\end{description}

We also present a simplified version of the $F_4$ algorithm in Algorithm~\ref{alg:f4}. For this, we need however to introduce the required notation.
 \begin{definition}
  Let $F  \subset  \F[x_0,\dots,x_{n-1}]$, and $(f,g) \in F \times F$ with $f \not =g$. We denote:
 $$
 \textsc{Pair}(f,g)=\big(\LCM{\LM{f},\LM{g}}, m_f,f,m_g,g\big),
 $$
 where $\LCM{\LM{f},\LM{g}}=\LM{m_g \cdot g}=\LM{m_f \cdot  f}$.
Now, let $P=\{\textsc{Pair}(f,g) \mid \forall (f,g) \in P \times P \mbox{ with } g > f\}, \textsc{p}=\textsc{Pair}(f,g) \in P$. We define \textsc{Left} and \textsc{Right} as:
\[
\begin{array}{cc}
    \textsc{Left}(\textsc{p})  =  (m_f,f)  &  \textsc{Right}(\textsc{p})  =  (m_g,g) ,\\
    & \\
    \textsc{Left}(P) = \bigcup_{\textsc{p} \in P} \textsc{Left}(\textsc{p}) &  \, \, \, \, \textsc{Right}(P) = \bigcup_{\textsc{p} \in P} \textsc{Right}(\textsc{p}).
 \end{array}
\]
 \end{definition}

\begin{algorithm}[ht]
\KwIn{$F$ -- a tuple of polynomials $f_0,\dots,f_{m-1}$}
\KwIn{$\textsc{Sel}$ -- a selection strategy}
\KwResult{a Gr\"obner basis for $F$}
\SetKw{Kwst}{such that}
\SetKw{KwAnd}{and}
\SetKw{KwWith}{with}
\Begin{
$G,i \longleftarrow F,0$\;
$\tilde{F}^+_i \longleftarrow F$\;
$P \longleftarrow \{\textsc{Pair}(f,g) \mid \forall f,g \in G$ \KwWith $g > f\}$\;
\While{$P \neq \varnothing$}{
  $i \longleftarrow i + 1$\;
  $P_i \longleftarrow$ $\textsc{Sel}(P)$\;
  $P \longleftarrow P\setminus P_i$\;
  $\mathcal{L}_i \longleftarrow$ Left($P_i$) $\bigcup$ Right($P_i$)\;
  \tcp{Symbolic Preprocessing}
  $F_i \longleftarrow \{t\cdot f \mid \forall (t,f) \in \mathcal{L}_i\}$\;
  $Done \longleftarrow \LM{F_i}$\;
  \While{$M(F) \neq Done$}{
    $m \longleftarrow$ an element in $M(F) \setminus Done$\;
    add $m$ to $Done$\;
    \If{$\exists\ g \in G \, \Kwst \, \LM{g}\ \mid \ m$}{
      $u = m/\LM{g}$\;
      add $u \cdot g$ to $F_i$\;
   }
  }
  \tcp{Gaussian Elimination}
  $\tilde{F}_i \longleftarrow $ the row echelon form of $F_i$\;
  $\tilde{F}_i^+ \longleftarrow \{f \in \tilde{F}_i\ |\ \LM{f} \not\in \LM{F}\}$\;
  \For{$h \in \tilde{F}^+_{i}$}{
    $P \longleftarrow P \bigcup \{\textsc{Pair}(f,h): \forall f \in G\}$\;
    add $h$ to $G$\;
  }
}
\Return{$G$}\;
}
\caption{$F_{4}$ (simplified)} 
\label{alg:f4}
\end{algorithm}
